stop("Desposits must be postive")
total<<-total+amount
cat(amount,"deposited. Youre balance is,", total)
},
withdraw<-function(amount){
if(amount>total)
stop("Youre broke dumbass")
total<<-total-amount
cat(amount, "withdrawn. Youre balance is:", total)
},
balance=function(){
cat("Youre balance is,", total)
}
)
}
test<-account(50)
test$balance()
test$withdraw(10)
account<- function (total){
list(
deposit<- function(amount){
if(amount <= 0)
stop("Desposits must be postive")
total<<-total + amount
cat(amount,"deposited. Youre balance is,", total)
},
withdraw<-function(amount){
if(amount>total)
stop("Youre broke dumbass")
total<<-total - amount
cat(amount, "withdrawn. Youre balance is:", total)
},
balance=function(){
cat("Youre balance is,", total)
}
)
}
test<-account(1000)
test$balance()
test$balance(10)
test$withdraw(10)
open.account <- function(total) {
list(
deposit = function(amount) {
if(amount <= 0)
stop("Deposits must be positive!\n")
total <<- total + amount
cat(amount, "deposited.  Your balance is", total, "\n\n")
},
withdraw = function(amount) {
if(amount > total)
stop("You don't have that much money!\n")
total <<- total - amount
cat(amount, "withdrawn.  Your balance is", total, "\n\n")
},
balance = function() {
cat("Your balance is", total, "\n\n")
}
)
}
test2<-open.account(100)
test2$balance()
test2$withdraw(10)
account<- function (total){
list(
deposit=function(amount){
if(amount <= 0)
stop("Desposits must be postive")
total<<-total + amount
cat(amount,"deposited. Youre balance is,", total)
},
withdraw=function(amount){
if(amount > total)
stop("Youre broke dumbass")
total<<-total - amount
cat(amount, "withdrawn. Youre balance is:", total)
},
balance=function(){
cat("Youre balance is,", total)
}
)
}
test<-account(100)
test$deposit(10)
test$withdraw(220)
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
set <- function(y) {
x <<- y
inv <<- NULL
}
get <- function() x
setInverse <- function(inverse) inv <<- inverse
getInverse <- function() inv
list(set = set,
get = get,
setInverse = setInverse,
getInverse = getInverse)
}
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inv <- x$getInverse()
if (!is.null(inv)) {
message("getting cached data")
return(inv)
}
mat <- x$get()
inv <- solve(mat, ...)
x$setInverse(inv)
inv
}
m<-makeChaceMatrix(matrix(1:4,2,2))
m<-makeCacheMatrix(matrix(1:4,2,2))
print(m)
m/
>
m
inv <- NULL
set <- function(y) {
x <<- y
inv <<- NULL
}
View(set)
View(set)
get <- function() x
View(set)
View(set)
View(get)
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
set <- function(y) {
x <<- y
inv <<- NULL
}
get <- function() x
setInverse <- function(inverse)inv <<- inverse
getInverse <- function()inv
}
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inv <- x$getInverse()
if (!is.null(inv)) {
message("getting cached data")
return(inv)
}
mat <- x$get()
inv <- solve(mat, ...)
x$setInverse(inv)
inv
}
mine<-makeCacheMatrix(matrix(1:4,2,2,))
mine$get()
mine<-makeCacheMatrix(matrix(1:4,2,2))
mine$get()
mine<-makeCacheMatrix(matrix(1:4,2,2))
mine$get()
get <- function()x
get
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
#set <- function(y) {
#       x <<- y
#      inv <<- NULL
#   }
get <- function()x
setInverse <- function(inverse) inv <<- inverse
getInverse <- function()inv
}
mine<- makeCacheMatrix(matrix(1:2,2,2))
makeCacheMatrix <- function(x = matrix()) {
xinv <- NULL # this is where the result of inversion is stored
# A setter function, use this to set a matrix to object created by makeCacheMatrix function
# e.g makeCacheMatrix(testmatrix) # here we work on testmatrix
# makeCacheMatrix$set(testmatrix1) # here we work on testmatrix1
set <- function(y) {
x <<- y
xinv <<- NULL # it also initialises xinv to null
}
get <- function() x # return the input matrix
setInv <- function(inv) xinv <<- inv # set the inversed matrix
getInv <- function() xinv # return the inversed matrix
# return a list that contains these functions, so that we can use
# makeCacheMatrix object like these
# x <- makeCacheMatrix(testmatrix)
# x$set(newmatrix) # to change matrix
# x$get # to get the setted matrix
# x$setInv # to set the inversed matrix
# x$getInv # to get the inversed matrix
list(set = set, get = get,
setInv = setInv,
getInv = getInv)
}
mine<- makeCacheMatrix(matrix(1:4,2,2))
mine$get()
makeCacheMatrix <- function(x = matrix()) {
xinv <- NULL # this is where the result of inversion is stored
# A setter function, use this to set a matrix to object created by makeCacheMatrix function
# e.g makeCacheMatrix(testmatrix) # here we work on testmatrix
# makeCacheMatrix$set(testmatrix1) # here we work on testmatrix1
set <- function(y) {
x <<- y
xinv <<- NULL # it also initialises xinv to null
}
get <- function() x # return the input matrix
setInv <- function(inv) xinv <<- inv # set the inversed matrix
getInv <- function() xinv # return the inversed matrix
# return a list that contains these functions, so that we can use
# makeCacheMatrix object like these
# x <- makeCacheMatrix(testmatrix)
# x$set(newmatrix) # to change matrix
# x$get # to get the setted matrix
# x$setInv # to set the inversed matrix
# x$getInv # to get the inversed matrix
#list(set = set, get = get,
#    setInv = setInv,
#   getInv = getInv)
}
mine<- makeCacheMatrix(matrix(1:4,2,2))
mine$get()
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL #Initializing where the inverse will be stored
setX<- function(y) { #Sets the matrix that will be worked with
x <<- y
inv <<- NULL
}
getX <- function() x #Simply grabbing the matrix
setInverse <- function(inverse) inv <<- inverse #Fuction to inverse the matrix
getInverse <- function() inv #Getting in the inverse
#Listing the functions so that they can used after makeCacheMatrix initializes X
list(setX = setX, get = getX,
setInverse = setInverse,
getInverse = getInverse)
}
#The following function calculates the inverse of the matrix that
# was created with the above function. However, it first checks to see if the
#inverse has already been calculated. If so, it `get`s the inverse from the
#cache and skips the computation. Otherwise, it calculates the mean of
#the data and sets the value of the mean in the cache via the `setmean`
#function.
cacheSolve <- function(x, ...) {
inv <- x$getInverse()
if(!is.null(inv)) {
message("Grabbing your stored/cached data for you!")
return(inv)
}
data <- x$get()
inv <- solve(data, ...)
x$setmean(inv)
inv
}
makeCacheMatrix(matrix(1:4,2,2))
x<-makeCacheMatrix(matrix(1:4,2,2))
x
## The following code can be used to:
## A) Create and store the inverse of a matrix
## B) Call a matrix, determine if its inverse has been computed and/or stored, then either compute the inverse or call the stored one
## The following fuction helps to create the matrix and can be used to store its inverse
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL #Initializing where the inverse will be stored
setX<- function(y) { #Sets the matrix that will be worked with
x <<- y
inv <<- NULL
}
getX <- function() x #Simply grabbing the matrix
setInverse <- function(inverse) inv <<- inverse #Fuction to inverse the matrix
getInverse <- function() inv #Getting in the inverse
#Listing the functions so that they can used after makeCacheMatrix initializes X
list(setX = setX, getX = getX,
setInverse = setInverse,
getInverse = getInverse)
}
#The following function calculates the inverse of the matrix that
# was created with the above function. However, it first checks to see if the
#inverse has already been calculated. If so, it `get`s the inverse from the
#cache and skips the computation. Otherwise, it calculates the mean of
#the data and sets the value of the mean in the cache via the `setmean`
#function.
cacheSolve <- function(x, ...) {
inv <- x$getInverse()
if(!is.null(inv)) {
message("Grabbing your stored/cached data for you!")
return(inv)
}
data <- x$get()
inv <- solve(data, ...)
x$setmean(inv)
inv
}
x<- makeCacheMatrix(maxtrix(1:8,2,4))
x$getX()
x<- makeCacheMatrix(matrix(1:8,2,4))
x$getX()
cacheSolve(x)
## The following code can be used to:
## A) Create and store the inverse of a matrix
## B) Call a matrix, determine if its inverse has been computed and/or stored, then either compute the inverse or call the stored one
## The following fuction helps to create the matrix and can be used to store its inverse
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL #Initializing where the inverse will be stored
setX<- function(y) { #Sets the matrix that will be worked with
x <<- y
inv <<- NULL
}
getX <- function() x #Simply grabbing the matrix
setInverse <- function(inverse) inv <<- inverse #Fuction to inverse the matrix
getInverse <- function() inv #Getting in the inverse
#Listing the functions so that they can used after makeCacheMatrix initializes X
list(setX = setX, getX = getX,
setInverse = setInverse,
getInverse = getInverse)
}
#The following function calculates the inverse of the matrix that
# was created with the above function. However, it first checks to see if the
#inverse has already been calculated. If so, it `get`s the inverse from the
#cache and skips the computation. Otherwise, it calculates the mean of
#the data and sets the value of the mean in the cache via the `setmean`
#function.
cacheSolve <- function(x, ...) {
inv <- x$getInverse()
if(!is.null(inv)) {
message("Grabbing your stored/cached data for you!")
return(inv)
}
data <- x$getX()
inv <- solve(data, ...)
x$setInverse(inv)
inv
}
x<- makeCacheMatrix(matrix(1:8,2,4))
x$getX()
solveCache(x)
cacheSolve(x)
x<- makeCacheMatrix(matrix(1:4,2,2))
solveCache(X)
cacheSolve(x)
cacheSolve(x)
library(datasets)
data("iris")
?iris
head(iris)
lapply(Sepal.Length, mean)
attach(iris)
lapply(Sepal.Length, mean)
sapply(Sepal.Length, mean)
head(iris)
mean(Sepal.Length[Species=='virginica'])
rowMeans(iris[,1:4])
rowMeans(iris[1:4,])
rowMeans(iris[1:4])
colMeans(iris[,1:4])
colMeans(iris)
colMeans(iris)
apply(iris,2,mean)
apply(iris[,1:4],2,mean)
attach(cars)
?cars
head(cars)
attach(mtcars)
?mtcars
head(mtcars)
tapply(mtcars$mpg, mtcars$cyl, mean)
abs(mean(mtcars[cyl=4]hp))
abs(mean(mtcars[cyl=4]$hp))
abs(mean(mtcars[cyl-=4]$hp))
abs(mean(mtcars[cyl==4]$hp))
abs(mean(mtcars[,cyl==4]$hp))
abs(mean(mtcars[,cyl==4]hp))
abs(mean(mtcars[cyl==4]hp))
debug
mean(hp[cyl==4]
)
mean(hp[cyl==4])-mean(hp[cyl==8])
mean(hp[cyl==4])-mean(hp[cyl==8])<-x
abs(mean(hp[cyl==4])-mean(hp[cyl==8]))
bebug(ls)
debug(ls)
ls
R.version.string
install.packages("swirl")
library(swirl)
swirl()
library(swirl)
install_from_swirl("Getting and Cleaning Data")
swirl()
read.csv(path2csv,stringsAsFactors = FALSE)
mydf<-read.csv(path2csv,stringsAsFactors = FALSE)
dim(mydf)
head()
head(mydf)
library(dplyr)
packageVersion(dplyr)
library(dplyr)
library("dplyr")
packageVersion("dplyr")
cran<-tbl_df(mydf)
rm("mydf")
?tbl_df
cran
?select
select(cran,ip_id,package,country)
5:20
select(cran,r_arch:country)
select(cran,country:r_arch)
cran
select(cran,-time)
select(cran,-X:Size)
select(cran,-X:size)
select(cran,-X:-size)
-5:20
-(5:20)
select(cran,-(X:-size))
select(cran,-(X:-ize))
select(cran,-(X:size))
filter(cran,package=="swirl")
filter(cran,r_version=="3.1.1",country=="US")
?Comparision
>Comparison
Comparison
?Comparison
filter(cran,r_version<="3.1.1",country=="India")
filter(cran,r_version<="3.1.1",country=="IN")
filter(cran,r_version<="3.0.2",country=="IN")
filter(cran,country=="US" | country=="IN")
filter(cran,size>100500, r_os=="linux-gnu")
is.na(c(3,5,NA,10))
!is.na(c(3,5,NA,10))
filter(cran,is.na(r_version)=TRUE)
filter(cran,is.na(r_version)==TRUE)
filter(cran,!is.na(r_version))
cran2<-select(cran,size:ip_id)
arrange(cran2,ip_id)
arrange(cran,desc(ip_id))
arrange(cran, desc(ip_id))
arrange(cran2, desc(ip_id))
arrange(cran2,package,ip_id)
arrange(cran2,country,desc(r_version), ip_id)
select(cran,ip_id,package,size)
select(cran, ip_id, package, size)
cran3<- select(cran,ip_id,package,size)
cran3
mutate(cran3, size_mb =size/2^20)
mutate(cran3, size_mb =size/2^20, size_gb=size_mb/2^10)
mutate(cran3,correct_size=size-1000)
mutate(cran3,correct_size=size+1000)
summarize(cran,avg_bytes=(mean(size)))
summarize(cran,avg_bytes=mean(size))
pnrom(93,mean=100,sd=10,upper.tail=FALSE)
pnorm(93,mean=100,sd=10,upper.tail=FALSE)
pnorm(93,mean=100,sd=10,lower.tail = TRUE)
pnorm(93,mean=100,sd=10)
pnorm(70,ean=80,sd=10)
pnorm(70,mean=80,sd=10)
pnorm(70,mean=80,sd=10, lower.tail = FALSE)
qnorm(95,mean=1100,sd=75, lower.tail = FALSE)
qnorm(95,mean=1100,sd=75)
qnorm(95)
pnorm(95)
qnorm(95)
answ3<-qnorm(95,mean=1100,sd=75)
round(answ3,0)
qnorm(0.95,mean=1100,sd=75)
qnorm(0.95,mean=1100,sd=75/10)
pnorm(4,0.5,lower.tail = FALSE)
pnorm(4,5,lower.tail = FALSE)
pnorm(4,size=5,prob=.5,lower.tail = FALSE)
pbinom(4,size=5,prob=.5,lower.tail = FALSE)
pbinom(3,size=5,prob=.5,lower.tail = FALSE)
ppois(10,14)
ppois(10,14,lower.tail = TRUE)
ppois(10,15,lower.tail = TRUE)
pnorm(70,mean=80,sd=10)
getwd()
setwd("..")
setwd("C:/Users/569375/Desktop/DSTB/repo/Peer2")
activity<-read.csv("activity.csv")
setwd("C:\Users\569375\Desktop\DSTB\repo\RepData_PeerAssessment1")
getwd()
setwd("..")
setwd("..")
getwd()
getwd()
setwd("..")
setwd("..")
setwd("C:\Users\569375\Desktop\DSTB\repo\RepData_PeerAssessment1")
setwd("..")
getwd()
setwd("..")
setwd("..")
getwd()
setwd("..")
getwd()
setwd("C:\Users\569375\Desktop\DSTB\repo\RepData_PeerAssessment1")
setwd("C:/Users/569375/Desktop/DSTB/repo/RepData_PeerAssessment1")
activity<-read.csv("activity.csv")
activity$date<-as.Date(activity$date)
activity<-na.omit(activity)
library(dplyr)
activity<-tbl_df(activity)
head(activity)
swirl()
activity<-tbl_df(activity)
daily_steps <- activity %>%
group_by(date) %>%
summarize(total_steps=sum(steps))
hist(daily_steps$total_steps, main="Total Steps per Day", xlab="Steps",col="purple")
hist(daily_steps$total_steps, main="Total Steps per Day", xlab="Steps",col="purple")
step_stats <- daily_steps %>%
summarize(mean_steps=mean(total_steps),median_steps=median(total_steps))
knit2html("PA1_template.rmd")
library(knitr)
knit2html("PA1_template.rmd")
knit2html("PA1_template.rmd")
